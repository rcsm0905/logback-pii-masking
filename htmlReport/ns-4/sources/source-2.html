


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > PiiDataMasker</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.example.logging</a>
</div>

<h1>Coverage Summary for Class: PiiDataMasker (com.example.logging)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PiiDataMasker</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.4%
  </span>
  <span class="absValue">
    (17/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.5%
  </span>
  <span class="absValue">
    (57/82)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.5%
  </span>
  <span class="absValue">
    (87/93)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.example.logging;
&nbsp;
&nbsp;import ch.qos.logback.core.spi.ContextAwareBase;
&nbsp;import ch.qos.logback.core.spi.LifeCycle;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.fasterxml.jackson.databind.ObjectMapper;
&nbsp;import com.fasterxml.jackson.databind.node.ArrayNode;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.fasterxml.jackson.databind.node.TextNode;
&nbsp;import lombok.Getter;
&nbsp;import lombok.Setter;
&nbsp;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;/**
&nbsp; * Log-level PII redaction utility used by {@link JsonStructuredLayout}.
&nbsp; *
&nbsp; * &lt;h2&gt;How it fits in the pipeline&lt;/h2&gt;
&nbsp; * &lt;pre&gt;
&nbsp; * ┌──────────────────────┐   ① build JSON tree
&nbsp; * │ JsonStructuredLayout │──▶ (timestamp, level, MDC, message…)
&nbsp; * └──────────────────────┘
&nbsp; *              │
&nbsp; *              │ ② in-place masking
&nbsp; *              ▼
&nbsp; *      ┌────────────────┐
&nbsp; *      │ PiiDataMasker  │ – masks all fields whose names are listed in
&nbsp; *      └────────────────┘   {@code &lt;maskedFields&gt;}.
&nbsp; *                           Works directly on the Jackson tree provided by the layout, therefore
&nbsp; *                           no extra parse/serialize round-trip is needed.
&nbsp; *              │
&nbsp; *              │ ③ layout serializes once (pretty/compact) and returns line
&nbsp; *              ▼
&nbsp; *        Logback appender
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;h3&gt;Public surface currently in use&lt;/h3&gt;
&nbsp; * &lt;li&gt; {@link #start()}, {@link #stop()}, {@link #isStarted()} – Logback life-cycle
&nbsp; * &lt;li&gt; {@link #maskJsonTree(com.fasterxml.jackson.databind.JsonNode)} – invoked by
&nbsp; *   {@code JsonStructuredLayout#doLayout}.
&nbsp; *
&nbsp; * &lt;h3&gt;Configuration&lt;/h3&gt;
&nbsp; * Supplied via {@code logback-spring.xml} and validated in {@link #start()}:
&nbsp; * &lt;ul&gt;
&nbsp; *   &lt;li&gt;{@code &lt;maskedFields&gt;}   – comma-separated field names&lt;/li&gt;
&nbsp; *   &lt;li&gt;{@code &lt;maskToken&gt;}      – replacement string (e.g. &quot;[REDACTED]&quot;)&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * &lt;h3&gt;Thread-safety&lt;/h3&gt;
&nbsp; * The class is immutable after {@link #start()} completes; recursion depth is
&nbsp; * tracked with a {@code ThreadLocal} so multiple threads can mask logs
&nbsp; * concurrently without interference.
&nbsp; *
&nbsp; * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; All code changes below are internal refactors: no behavior or public
&nbsp; * contract has been altered.&lt;/p&gt;
&nbsp; */
&nbsp;@Setter
&nbsp;@Getter
<b class="fc">&nbsp;public class PiiDataMasker extends ContextAwareBase implements LifeCycle {</b>
&nbsp;
&nbsp;	/* ───────────── constants ───────────── */
&nbsp;
<b class="fc">&nbsp;	private static final ObjectMapper COMPACT_MAPPER = new ObjectMapper();</b>
&nbsp;
&nbsp;	private static final int MAX_RECURSION_DEPTH = 10;
<b class="fc">&nbsp;	private static final ThreadLocal&lt;Integer&gt; RECURSION_DEPTH =</b>
<b class="fc">&nbsp;			ThreadLocal.withInitial(() -&gt; 0);                // renamed: UPPER_SNAKE for constants</b>
&nbsp;
&nbsp;	private static final int MAX_JSON_SCAN = 100_000;    // scan limit for brace matching
<b class="fc">&nbsp;	private static final Pattern FIELD_CLEANER = Pattern.compile(&quot;[^A-Za-z0-9_]&quot;);</b>
&nbsp;
&nbsp;	/* ───────────── state ───────────── */
&nbsp;
<b class="fc">&nbsp;	private final AtomicBoolean started = new AtomicBoolean(false);</b>
&nbsp;
&nbsp;	private String maskedFields;
&nbsp;	private String maskToken;
<b class="fc">&nbsp;	private Set&lt;String&gt; fieldNamesToMask = Collections.emptySet();</b>
&nbsp;
&nbsp;	/* ───────────── life-cycle ───────────── */
&nbsp;
&nbsp;	@Override
&nbsp;	public void start() {
<b class="fc">&nbsp;		if (started.get()) return;        // idempotent</b>
&nbsp;
&nbsp;		try {
&nbsp;			/* ─── validate &amp; initialise ─── */
<b class="fc">&nbsp;			maskToken        = requireNonBlank(maskToken, &quot;&lt;maskToken&gt;&quot;);</b>
<b class="fc">&nbsp;			fieldNamesToMask = parseAndValidateFields(maskedFields);</b>
&nbsp;
<b class="fc">&nbsp;			started.set(true);</b>
&nbsp;		} catch (Exception ex) {
<b class="fc">&nbsp;			addError(&quot;PII masking initialisation failed&quot;, ex);</b>
<b class="fc">&nbsp;			throw new IllegalStateException(&quot;PII masking init failed&quot;, ex);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override public void stop() {
<b class="fc">&nbsp;		if (!started.getAndSet(false)) return;</b>
<b class="fc">&nbsp;		RECURSION_DEPTH.remove();</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	@Override public boolean isStarted() { return started.get(); }</b>
&nbsp;
&nbsp;	/* ───────────── public API ───────────── */
&nbsp;
&nbsp;	/**
&nbsp;	 * Mask the given tree in-place.  Null-safe.
&nbsp;	 *
&nbsp;	 * @param root the JSON node to sanitize; ignored when {@code null}
&nbsp;	 */
&nbsp;	public void maskJsonTree(JsonNode root) {
<b class="fc">&nbsp;		if (root != null) maskJsonTreeInternal(root);</b>
&nbsp;	}
&nbsp;
&nbsp;	/* ───────────── validation helpers ───────────── */
&nbsp;	/**
&nbsp;	 * Ensure the supplied string is not null / blank.
&nbsp;	 *
&nbsp;	 * @return the same value, allowing inline assignment
&nbsp;	 * @throws IllegalStateException if the check fails
&nbsp;	 */
&nbsp;	private static String requireNonBlank(String v, String fieldName) {
<b class="pc">&nbsp;		if (v == null || v.isBlank()) {</b>
<b class="fc">&nbsp;			throw new IllegalStateException(fieldName + &quot; must be configured&quot;);</b>
&nbsp;		}
<b class="fc">&nbsp;		return v;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Parse the CSV list from &lt;maskedFields&gt;, clean each token and return an
&nbsp;	 * *immutable* set.
&nbsp;	 *
&nbsp;	 * @throws IllegalStateException when the CSV is blank or contains no
&nbsp;	 *                               usable field names.
&nbsp;	 */
&nbsp;	private static Set&lt;String&gt; parseAndValidateFields(String csv) {
<b class="fc">&nbsp;		String src = requireNonBlank(csv, &quot;&lt;maskedFields&gt;&quot;);</b>
&nbsp;
<b class="fc">&nbsp;		Set&lt;String&gt; out = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;		for (String part : src.split(&quot;,&quot;)) {</b>
<b class="fc">&nbsp;			String token = FIELD_CLEANER.matcher(part.trim()).replaceAll(&quot;&quot;);</b>
<b class="pc">&nbsp;			if (!token.isEmpty() &amp;&amp; token.length() &lt;= 50) {</b>
<b class="fc">&nbsp;				out.add(token);</b>
&nbsp;			}
&nbsp;		}
<b class="pc">&nbsp;		if (out.isEmpty()) {</b>
<b class="nc">&nbsp;			throw new IllegalStateException(&quot;&lt;maskedFields&gt; produced no valid entries&quot;);</b>
&nbsp;		}
<b class="fc">&nbsp;		return Collections.unmodifiableSet(out);</b>
&nbsp;	}
&nbsp;
&nbsp;	/* ───────────── masking traversal ───────────── */
&nbsp;
&nbsp;	private void maskJsonTreeInternal(JsonNode root) {
<b class="pc">&nbsp;		if (RECURSION_DEPTH.get() &gt;= MAX_RECURSION_DEPTH) return;</b>
&nbsp;
<b class="fc">&nbsp;		RECURSION_DEPTH.set(RECURSION_DEPTH.get() + 1);</b>
&nbsp;		try {
<b class="fc">&nbsp;			traverseAndMaskTree(root);</b>
&nbsp;		} finally {
<b class="fc">&nbsp;			RECURSION_DEPTH.set(RECURSION_DEPTH.get() - 1);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * (original detailed Javadoc kept)
&nbsp;	 */
&nbsp;	private void traverseAndMaskTree(JsonNode root) {
<b class="fc">&nbsp;		Deque&lt;JsonNode&gt; stack = new ArrayDeque&lt;&gt;();</b>
<b class="fc">&nbsp;		stack.push(root);</b>
&nbsp;
<b class="fc">&nbsp;		while (!stack.isEmpty()) {</b>
<b class="fc">&nbsp;			JsonNode node = stack.pop();</b>
&nbsp;
<b class="fc">&nbsp;			if (node.isObject()) {</b>
<b class="fc">&nbsp;				ObjectNode obj = (ObjectNode) node;</b>
<b class="fc">&nbsp;				List&lt;String&gt; toMask = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;				obj.fields().forEachRemaining(entry -&gt; {</b>
<b class="fc">&nbsp;					String name   = entry.getKey();</b>
<b class="fc">&nbsp;					JsonNode value = entry.getValue();</b>
&nbsp;
<b class="fc">&nbsp;					if (fieldNamesToMask.contains(name)) {</b>
<b class="fc">&nbsp;						toMask.add(name);</b>
<b class="fc">&nbsp;					} else if (looksLikeJsonString(value)) {</b>
<b class="fc">&nbsp;						handleNestedJsonString(obj, name, value, stack);</b>
&nbsp;					} else {
<b class="fc">&nbsp;						stack.push(value);</b>
&nbsp;					}
&nbsp;				});
&nbsp;
<b class="fc">&nbsp;				toMask.forEach(f -&gt; obj.set(f, maskValue(obj.get(f))));</b>
&nbsp;			}
&nbsp;
<b class="pc">&nbsp;			else if (node.isArray()) {</b>
<b class="nc">&nbsp;				node.elements().forEachRemaining(stack::push);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/* ───────────── embedded JSON helpers ───────────── */
&nbsp;
&nbsp;	private static boolean looksLikeJsonString(JsonNode n) {
<b class="fc">&nbsp;		return n.isTextual() &amp;&amp; isJsonLike(n.asText());</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean isJsonLike(String v) {
<b class="pc">&nbsp;		return v != null &amp;&amp; v.length() &gt; 1 &amp;&amp;</b>
<b class="pc">&nbsp;				((v.indexOf(&#39;{&#39;) != -1 &amp;&amp; v.indexOf(&#39;}&#39;) != -1) ||</b>
<b class="pc">&nbsp;						(v.indexOf(&#39;[&#39;) != -1 &amp;&amp; v.indexOf(&#39;]&#39;) != -1));</b>
&nbsp;	}
&nbsp;
&nbsp;	private void handleNestedJsonString(
&nbsp;			ObjectNode parent, String field, JsonNode value, Deque&lt;JsonNode&gt; stack) {
&nbsp;
<b class="fc">&nbsp;		String text = value.asText();</b>
<b class="fc">&nbsp;		String json = extractJsonFromString(text);</b>
<b class="pc">&nbsp;		if (json == null) {                       // treat as plain text</b>
<b class="nc">&nbsp;			stack.push(value);</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		try {
<b class="fc">&nbsp;			JsonNode nested = COMPACT_MAPPER.readTree(json);</b>
<b class="fc">&nbsp;			maskJsonTreeInternal(nested);</b>
<b class="fc">&nbsp;			parent.put(field, text.replace(json,</b>
<b class="fc">&nbsp;					COMPACT_MAPPER.writeValueAsString(nested)));</b>
&nbsp;		} catch (Exception ex) {
<b class="nc">&nbsp;			stack.push(value);                      // fallback: keep original</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/* ───────────── brace matching (unchanged) ───────────── */
&nbsp;
&nbsp;	private String extractJsonFromString(String v) {
<b class="fc">&nbsp;		int brace = v.indexOf(&#39;{&#39;);</b>
<b class="fc">&nbsp;		int bracket = v.indexOf(&#39;[&#39;);</b>
<b class="pc">&nbsp;		int start = (brace != -1 &amp;&amp; (bracket == -1 || brace &lt; bracket)) ? brace : bracket;</b>
<b class="pc">&nbsp;		if (start == -1) return null;</b>
&nbsp;
<b class="fc">&nbsp;		int end = findMatchingBrace(v, start, v.charAt(start),</b>
<b class="pc">&nbsp;				(v.charAt(start) == &#39;{&#39;) ? &#39;}&#39; : &#39;]&#39;);</b>
<b class="pc">&nbsp;		return (end != -1) ? v.substring(start, end + 1) : null;</b>
&nbsp;	}
&nbsp;
&nbsp;	private int findMatchingBrace(String text, int openIdx, char open, char close) {
<b class="fc">&nbsp;		boolean inString = false, escaped = false;</b>
<b class="fc">&nbsp;		int depth = 1;</b>
<b class="fc">&nbsp;		int limit = Math.min(openIdx + MAX_JSON_SCAN, text.length());</b>
&nbsp;
<b class="pc">&nbsp;		for (int i = openIdx + 1; i &lt; limit; i++) {</b>
<b class="fc">&nbsp;			char c = text.charAt(i);</b>
&nbsp;
<b class="pc">&nbsp;			if (escaped) { escaped = false; continue; }</b>
<b class="pc">&nbsp;			if (c == &#39;\\&#39;) { escaped = true; continue; }</b>
&nbsp;
<b class="fc">&nbsp;			if (c == &#39;&quot;&#39;) { inString = !inString; continue; }</b>
<b class="fc">&nbsp;			if (inString) continue;</b>
&nbsp;
<b class="fc">&nbsp;			if (c == open) depth++;</b>
<b class="fc">&nbsp;			else if (c == close &amp;&amp; --depth == 0) return i;</b>
&nbsp;		}
<b class="nc">&nbsp;		return -1;</b>
&nbsp;	}
&nbsp;
&nbsp;	/* ───────────── masking values ───────────── */
&nbsp;
&nbsp;	private JsonNode maskValue(JsonNode original) {
<b class="pc">&nbsp;		if (original == null || original.isNull()) return original;</b>
&nbsp;
<b class="fc">&nbsp;		if (original.isArray()) {</b>
<b class="fc">&nbsp;			ArrayNode a = COMPACT_MAPPER.createArrayNode();</b>
<b class="fc">&nbsp;			original.forEach(n -&gt; a.add(maskToken));   // keep identical size</b>
<b class="fc">&nbsp;			return a;</b>
&nbsp;		}
<b class="fc">&nbsp;		if (original.isObject()) {</b>
<b class="fc">&nbsp;			ObjectNode o = COMPACT_MAPPER.createObjectNode();</b>
<b class="fc">&nbsp;			original.fieldNames().forEachRemaining(f -&gt; o.put(f, maskToken));</b>
<b class="fc">&nbsp;			return o;</b>
&nbsp;		}
<b class="fc">&nbsp;		return TextNode.valueOf(maskToken);          // primitives</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-10-14 17:53</div>
</div>
</body>
</html>
